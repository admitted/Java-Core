# 生产者与消费者
```
/*
 * 生产者/消费者问题
 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，
 * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，
 * 如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，
 * 如果店中有产品了再通知消费者来取走产品。

 分析：
 1.是否涉及到多线程的问题？是！生产者、消费者
 2.是否涉及到共享数据？有！考虑线程的安全
 3.此共享数据是谁？即为产品的数量
 4.是否涉及到线程的通信呢？存在生产者与消费者的通信
 */

public class TestPCC {
      public static void main(String[] args) {
            Clerk1 clerk = new Clerk1();
            
            Productor1 p1 = new Productor1(clerk);
            Customers1 c1 = new Customers1(clerk);
            Thread t1 = new Thread(p1);
            Thread t4 = new Thread(p1);
            Thread t2 = new Thread(c1);
            t1.setName( "生产者1");
            t2.setName( "消费者1");
            t4.setName( "生产者2");

            t1.start();
            t2.start();
            t4.start();

      }
}

class Clerk1 {
      int product;
      
      public synchronized void buyProduct() {
             if ( product >= 20) {
                   try {
                        wait();
                  } catch (InterruptedException e) {
                         // TODO Auto-generated catch block
                        e.printStackTrace();
                  }
            } else {
                   product++;
                  System. out.println(Thread. currentThread().getName() + ":生产了第"
                              + product + "个产品");
                  notifyAll();
            }
      }

      public synchronized void sellProduct() {
             if ( product <= 0) {
                   try {
                        wait();
                  } catch (InterruptedException e) {
                         // TODO Auto-generated catch block
                        e.printStackTrace();
                  }
            } else {
                  System. out.println(Thread. currentThread().getName() + ":消费了第"
                              + product + "个产品");
                   product--;   //注意位置    先打印在--
                  notifyAll();
            }

      }


}

class Productor1 implements Runnable {
      Clerk1 clerk;

      public Productor1(Clerk1 clerk) {
             this. clerk = clerk;
      }

      @Override
      public void run() {
            System. out.println( "生产者生产产品！" );
             while ( true) {
                   try {
                         Thread.currentThread().sleep(100);
                  } catch (InterruptedException e) {
                         // TODO Auto-generated catch block
                        e.printStackTrace();
                  }
                   this. clerk.buyProduct();
            }

      }
}

class Customers1 implements Runnable {
      Clerk1 clerk;

      public Customers1(Clerk1 clerk) {
             this. clerk = clerk;
      }

      @Override
      public void run() {
            System. out.println( "消费者消费产品！" );
             while ( true) {
                   try {
                         Thread.currentThread().sleep(100);
                  } catch (InterruptedException e) {
                         // TODO Auto-generated catch block
                        e.printStackTrace();
                  }
                   this. clerk.sellProduct();
            }

      }
}
```


