# 方法

## 方法的重载（overload）
要求：
    1. 同一个类中 
    2. 方法名必须相同
    3. 方法的参数列表不同（①参数的个数不同  或者  ②参数类型不同）
    补充：方法的重载与方法的返回值类型没有关系！
  
  
```    
 public class TestOverload {
     
 }
 class OverLoad{
      //定义两个int型变量的和
      public int getSum( int i, int j){
             return i + j;
      }
      //定义三个int型变量的和
      public int getSum( int i, int j, int k){
             return i + j + k;
      }
      //不能与其它几个方法构成重载
 //   public int getSum1( int i, int j,int k){
//             return i + j + k;
 //   }
 //   public void getSum( int i, int j,int k){
//             System.out.println(i + j + k);
 //   }
      //定义两个double型数据的和
      public double getSum( double d1, double d2){
             return d1 + d2;
      }
     
      //定义三个double型数组的和
      public void getSum( double d1, double d2, double d3){
            System.out.println(d1 + d2 + d3);
      }

      //以下的两个方法构成重载。
      public void method1( int i,String str){
           
      }
      public void method1(String str1, int j){
           
      }
 }
```

## 可变个数形参的方法：
 * 格式：对于方法的形参： 数据类型 ...   形参名
 * 可变个数的形参的方法与同名的方法之间构成重载
 * 可变个数的形参在调用时，个数从0开始，到无穷多个都可以。
 * 使用可变多个形参的方法与方法的形参使用数组是一致的。
 * 若方法中存在可变个数的形参，那么一定要声明在方法形参的最后。
 * 在一个方法中，最多声明一个可变个数的形参。


```
public class TestArgs {
     public static void main(String[] args) {
           TestArgs t = new TestArgs();
           t.sayHello();
            //t.sayHello(new String[]{"hello China","hello BeiJing"});
           t.sayHello( "hello China","hello BeiJing" );
     }
     
//如下四个方法构成重载
//在类中一旦定义了重载的可变个数的形参的方法以后，如下的两个方法可以省略
//   public void sayHello(){
//         System.out.println("hello world!");
//   }
//   public void sayHello(String str1){
//         System.out.println("hello " + str1);
//   }
     //可变个数的形参的方法
     public void sayHello(String ... args){
            for( int i = 0;i < args.length;i++){
                System.out.println(args[i] + "$");
           }
            //System.out.println("=====");
     }
     
     public void sayHello(int i,String ... args){
     //public void sayHello(String ... args, int i){
           System.out.println(i);
           
            for( int j = 0;j < args.length;j++){
                System.out.println(args[j] + "$");
           }
     }
     
     public void sayHello1(String[] args){
            for( int i = 0;i < args.length;i++){
                System.out.println(args[i]);
           }
     }
     
     //可变个数形参的使用的例子
//   public int getSum(int i, int j){
//         return i + j;
//   }
//   public int getSum(int i, int j,int k){
//         return i + j + k;
//   }
     public int getSum(int ... args){
            int sum = 0;
            for( int i = 0;i < args.length;i++){
                sum += args[i];
           }
            return sum;
     }          
}
```

## 方法的参数传递（重点、难点）
1、形参与实参

* 形参：方法声明时，方法小括号内的参数
* 实参：调用方法时，实际传入的参数的值
 
2、规则：java中的参数传递机制：值传递机制

* 形参是基本数据类型的：将实参的值传递给形参的基本数据类型的变量
* 形参是引用数据类型的：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。

**从程序运行的角度来看，参数传递，只有传值，从不传递其它的东西。只不过值的内容有可能是数据，也有可能是一个内存地址**

Java中的数据类型有两大类，即基本类型(primitive types), 共有8种，包括int, short, long, byte, float, double, boolean, char，存在于栈（Stack）中。另一种暂称为对象类型，包括Integer, String, Double等相应基本数据类型的包装类，以及其他所有JAVA自带和用户自定义的类,这些类数据全部存在于堆中（Heap）。

|  | Heap( 堆) | Stack( 栈) |
| --- | --- | --- |
|  JVM 中的功能  | 存储数据  |  内存指令区 |
| 存储 | 对象实例 | 基本数据类型 , 指令代码, 常量 , 对象引用地址 |

```
@Test
public void Test5() {
    int i = 1;
    System.out.println( "Before test: i = " + i);
    changeValue(i);
    System.out.println( "After test: i = " + i);
}

public static void changeValue(int i) {
    i = 2;
    System.out.println( "during test: i = " + i);
}
```

运行结果：

```
Before test: i = 1
during test: i = 2
After test: i = 1
```

**不难看出，虽然在 changeValue(int i)方法中改变了传进来的参数的值，但对这个参数源变量本身并没有影响。其内部原理是，main方法里的变量和changeValue方法的参数是两个不同的变量，以参数形式传递简单类型的变量时，实际上是将参数的值作了一个拷贝传进方法的，那么在方法里再怎么改变其值，其结果都是只改变了拷贝的值，而不是源值。**

```
@Test
public void test6() {
    StringBuffer string = new StringBuffer("Hello");
    test6(string);
    System.out.println(string);
}

public void test6(StringBuffer str) {
    str.append(", World!");
}
```
运行结果：

```
Hello, World!
```
在这个例子里，似乎变量string被“改变”了。但其实改变的并不是string变量本身，也就是说string保存的内存地址并没有被改变，改变的是它所指向的对象实例。内部原理是这样的，在main方法里定义了一个对象引用string，并且把它和一个对象实例关联new StringBuffer。方法调用的时候，string所保存的对象实例的内存地址传递给了test方法的对象引用参数str，这时就有两个对象引用变量指向同一个对象实例。这两个对象引用都可以对该对象实例进行操作，操作结果都有效，因此在test方法执行完之后，对象实例的内容已经被改变了，这个时候再通过main方法里的string引用去查看对象实例的内容，看到的就是改变之后的内容。

```
@Test
public void test7() {
    String string = "Hello";
    test7(string);
    System. out.println(string);
}

public void test7(String str) {
    str = "World";  
    //将str 原先的地址改为 world 字符的地址,对原地址没有任何影响
}
```
运行结果：

```
Hello
```
这个结果和上面结果矛盾吗？一点也不矛盾。在这个例子中，参数传递过程和上个例子完全一样，但是在test方法里并不是对原来指向的对象实例进行操作，而是把str指向了另外一个对象实例，当然对原来的对象实例毫无影响。




